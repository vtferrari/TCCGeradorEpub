package integracao;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.After;
import org.junit.Test;
import tcc.vinicius.mvc.controler.LivroController;
import tcc.vinicius.mvn.model.Capitulo;

public class GerarUmEpubTest {
    @After
    public void depois() {
        List<File> files = new ArrayList<>();
        files.add(new File("Test-Driven Development como alterantiva de garantia de qualidade no desenvolvimento de software_Viniciu_capitulo1.html"));
        files.add(new File("Test-Driven Development como alterantiva de garantia de qualidade no desenvolvimento de software_Viniciu_capitulo2.html"));
        files.add(new File("Test-Driven Development como alterantiva de garantia de qualidade no desenvolvimento de software_Viniciu_capitulo3.html"));
        files.add(new File("Test-Driven Development como alterantiva de garantia de qualidade no desenvolvimento de software_Viniciu_Introdução.html"));
        for (File file : files) {
            if (file.exists()) {
                file.delete();
            }
            
        }
    }

    
    @Test
    public void gerarEpub() throws Exception {
        LivroController livroController = new LivroController();
        livroController.getLivro().setEditora("Fatec");
        livroController.getLivro().setTitulo("Test-Driven Development como alterantiva de garantia de qualidade no desenvolvimento de software");
        livroController.getLivro().setNomeAutor("Viniciu");
        livroController.getLivro().setSobrenomeAutor("Ferrari");
        livroController.addCapitulo(capitulo("Introdução", "#INTRODUÇÃO#\nO desenvolvimento de software passou por incríveis mudanças desde o início da era da informática, o avanço de linguagens e formas de como trabalhar a favor das linguagens e as novas metodologias trouxeram reuso e reaproveitamento de linhas de código, transformou a linguagem estruturada, que era difícil de se compreender, e também deu suporte a sistemas antigos ou sistemas de outros programadores, trazendo ao mundo real o modelo de objetos.\nOs sistemas orientados a objetos deveriam ser mais fáceis de entender, ler, dar manutenção, porém problemas parecidos com o paradigma estruturado tornaram a aparecer como: códigos extensos, inconsistentes e duplicados, obrigando especialistas a criar maneiras de tornar os sistemas padrões mais fáceis de serem modificados e compreendidos, criando linguagens de modelagem como a //Unified Modeling Language// (**UML**) e até ferramentas para melhorar a qualidade no decorrer do desenvolvimento do software. Mesmo assim o tempo, recursos e custos despendidos em direção a qualidade ainda é grande, e há o risco de no final o projeto tornar-se obsoleto.\nEstudiosos de engenharia de software buscam diminuir o risco tanto da obsolescência quanto dos altos custos e tempo. Pensando nisso, Beck (2010) defende o Desenvolvimento Guiado por Testes, do inglês //Test-Driven Developement// (**__TDD__**).\nResumidamente, o **TDD** guia por meio de pequenos passos para que se alcance o Todo, que é a conclusão do projeto, baseando-se em especificações que foram previamente definidas. Dessa forma, caso precise fazer qualquer mudança, basta rodar os testes e assim garantir que o Todo continue a funcionar.\n**TDD** não é somente isso, tem muito mais a agregar e a colaborar com a engenharia de software, entretanto, mesmo com a popularização do //TDD//. A técnica é ainda subutilizada pelos desenvolvedores, já que ela não é somente uma técnica de desenvolvimento, mas também uma técnica de projeto. (__GUERRA ,2012__)\n**//Beck// (__2010__)**, apresenta um conjunto de técnicas com uma linguagem acessível para qualquer engenheiro de software, com a intenção de encorajar a aplicabilidade de TDD em qualquer projeto e assim proporcionar oportunidades para que os profissionais do ramo possam trabalhar mais próximos do potencial real.\nCom base na importância e colaboração que o TDD pode agregar à engenharia de software, esta pesquisa apresenta uma aplicação de **TDD** por meio de um exemplo prático.\nEste trabalho tem por objetivo desenvolver uma aplicação Web aplicando Test-Driven Development (TDD) como alternativa de garantia de qualidade no desenvolvimento de software. A aplicação deve ser capaz de interpretar texto sinalizado com caracteres especiais para marcar e transformar em um arquivo //e-Pub// (__e-book__, **livro digital**), além de estudar as métricas de qualidade na produção da aplicação, garantir a legibilidade do código produzido, analisar a escalabilidade e a tolerância à mudança de requisitos do sistema, e também a influência do TDD no design do projeto.\nO desenvolvimento de um software é algo complexo e delicado, mesmo compondo uma significante parcela do nosso dia-a-dia. Profissionais de todos os ramos munem-se de aplicações de software para facilitar atividades profissionais. À medida que a complexidade do problema aumenta, a qualidade tende a diminuir, isso porque é difícil documentar todas as necessidades. Com isso surgiu uma revolução nos métodos de desenvolvimento por meio do manifesto ágil, que aconteceu em 2001. Foram definidos vários padrões tanto de modelagem quanto de desenvolvimento ou, como também métodos de melhores práticas para tentar solucionar os principais problemas de qualidade de software e entre produtos de software que satisfazem os **stakeholders. (__BECK__ //et al., 2001//)**\n__Crispin__ (2006) mostra que durante um processo de desenvolvimento de software, a qualidade e a satisfação dos stakeholders, são garantidas ao utilizar o desenvolvimento ágil somado à técnica de **TDD**.\n###\"###\n**Of course, defect rate is just one small measure of quality. If you could talk to our business stakeholders, you’d find they’re satisfied, often even delighted, that we deliver just what they asked for each iteration. We’ve implemented features that competing companies thought were too complex to automate. Many factors come into play, including other agile practices such as short iterations, continuous integration, and refactoring. However, I think our ability to understand and capture business requirements, and then code to meet them, is a critical reason for our success. (CRISPIN, 2006, p. 71, grifo do autor) **\n###\"###\nClaro, a taxa de defeito é apenas uma pequena medida de qualidade. Se você pudesse falar com nossos stakeholders do negócio, você acharia que eles estão satisfeitos, muitas vezes até, encantados, que nós entregamos"));
        livroController.addCapitulo(capitulo("capitulo1", "#1. Fundamentação teórica#\nEste capítulo aborta os principais tópicos de qualidade que foram utilizados no trabalho.\n##1.1. Qualidade##\n__Weinberg (1993)__ aponta a questão da relatividade quanto à qualidade, pois para ele é preciso examinar com muito cuidado porque definições como “a qualidade é a conformidade às exigências” se transformam em “às exigências de alguma pessoa” isto porque o mesmo produto detém aspectos de qualidade diferentes de acordo com cada ponto de vista. Assim, __Weinberg (1993, p. 6)__ quanto às definições de qualidade de software ele se pergunta “Quem é a pessoa por trás dessa definição de qualidade?”\n__Weinberg (1993, p. 6)__ cita algumas “ideias familiares”, porém conflitantes sobre qualidade de software:\n###\"###\n\n Defeito zero é a alta qualidade\na) Para os usuários cujo trabalho é afetado pelos defeitos.\nb) Para os gerentes que são criticados pelos defeitos.\nTer um grande número de funções é alta qualidade\na) Para os usuários cujo trabalho pode tirar proveito dessas funções – se eles as conhecerem.\nb) Para os distribuidores que acreditam que as funções vendem produtos.\nCodificação elegante é alta qualidade\na) Para o pessoal de desenvolvimento que dá um grande valor às opiniões de seus colegas.\nb) Para os professores de ciência da computação que apreciam elegância.\nAlto desempenho é alta qualidade\na) Para os usuários cujo trabalho sobrecarrega a capacidade de suas máquinas.\nb) Para o pessoal de venda que tem de submeter seus produtos à benchmarks.\nBaixo custo de desenvolvimento é alta qualidade\na) Para os usuários cujo trabalho sobrecarrega a capacidade de suas máquinas.\nb) Para os gerentes do projeto que estão com orçamentos apertados.\nDesenvolvimento rápido é alta qualidade\na) Para os usuários cujo trabalho está esperando pelo software.\nb) Para os distribuidores que desejam colonizar um mercado antes de seus concorrentes.\nFacilidade para o usuário (userfriendliness) é alta qualidade\na) Para os usuários que gastam oito horas por ida na frente de uma tela utilizando o software.\nb) Para os usuários que não conseguem se lembrar de detalhes de interface (WEINBERG, 1993, p. 6-7).\n###\"###"));
        livroController.addCapitulo(capitulo("capitulo2", "#INTRODUÇÃO#\nO desenvolvimento de software passou por incríveis mudanças desde o início da era da informática, o avanço de linguagens e formas de como trabalhar a favor das linguagens e as novas metodologias trouxeram reuso e reaproveitamento de linhas de código, transformou a linguagem estruturada, que era difícil de se compreender, e também deu suporte a sistemas antigos ou sistemas de outros programadores, trazendo ao mundo real o modelo de objetos.\nOs sistemas orientados a objetos deveriam ser mais fáceis de entender, ler, dar manutenção, porém problemas parecidos com o paradigma estruturado tornaram a aparecer como: códigos extensos, inconsistentes e duplicados, obrigando especialistas a criar maneiras de tornar os sistemas padrões mais fáceis de serem modificados e compreendidos, criando linguagens de modelagem como a //Unified Modeling Language// (**UML**) e até ferramentas para melhorar a qualidade no decorrer do desenvolvimento do software. Mesmo assim o tempo, recursos e custos despendidos em direção a qualidade ainda é grande, e há o risco de no final o projeto tornar-se obsoleto.\nEstudiosos de engenharia de software buscam diminuir o risco tanto da obsolescência quanto dos altos custos e tempo. Pensando nisso, Beck (2010) defende o Desenvolvimento Guiado por Testes, do inglês //Test-Driven Developement// (**__TDD__**).\nResumidamente, o **TDD** guia por meio de pequenos passos para que se alcance o Todo, que é a conclusão do projeto, baseando-se em especificações que foram previamente definidas. Dessa forma, caso precise fazer qualquer mudança, basta rodar os testes e assim garantir que o Todo continue a funcionar.\n**TDD** não é somente isso, tem muito mais a agregar e a colaborar com a engenharia de software, entretanto, mesmo com a popularização do //TDD//. A técnica é ainda subutilizada pelos desenvolvedores, já que ela não é somente uma técnica de desenvolvimento, mas também uma técnica de projeto. (__GUERRA ,2012__)\n**//Beck// (__2010__)**, apresenta um conjunto de técnicas com uma linguagem acessível para qualquer engenheiro de software, com a intenção de encorajar a aplicabilidade de TDD em qualquer projeto e assim proporcionar oportunidades para que os profissionais do ramo possam trabalhar mais próximos do potencial real.\nCom base na importância e colaboração que o TDD pode agregar à engenharia de software, esta pesquisa apresenta uma aplicação de **TDD** por meio de um exemplo prático.\nEste trabalho tem por objetivo desenvolver uma aplicação Web aplicando Test-Driven Development (TDD) como alternativa de garantia de qualidade no desenvolvimento de software. A aplicação deve ser capaz de interpretar texto sinalizado com caracteres especiais para marcar e transformar em um arquivo //e-Pub// (__e-book__, **livro digital**), além de estudar as métricas de qualidade na produção da aplicação, garantir a legibilidade do código produzido, analisar a escalabilidade e a tolerância à mudança de requisitos do sistema, e também a influência do TDD no design do projeto.\nO desenvolvimento de um software é algo complexo e delicado, mesmo compondo uma significante parcela do nosso dia-a-dia. Profissionais de todos os ramos munem-se de aplicações de software para facilitar atividades profissionais. À medida que a complexidade do problema aumenta, a qualidade tende a diminuir, isso porque é difícil documentar todas as necessidades. Com isso surgiu uma revolução nos métodos de desenvolvimento por meio do manifesto ágil, que aconteceu em 2001. Foram definidos vários padrões tanto de modelagem quanto de desenvolvimento ou, como também métodos de melhores práticas para tentar solucionar os principais problemas de qualidade de software e entre produtos de software que satisfazem os **stakeholders. (__BECK__ //et al., 2001//)**\n__Crispin__ (2006) mostra que durante um processo de desenvolvimento de software, a qualidade e a satisfação dos stakeholders, são garantidas ao utilizar o desenvolvimento ágil somado à técnica de **TDD**.\n###\"###\n**Of course, defect rate is just one small measure of quality. If you could talk to our business stakeholders, you’d find they’re satisfied, often even delighted, that we deliver just what they asked for each iteration. We’ve implemented features that competing companies thought were too complex to automate. Many factors come into play, including other agile practices such as short iterations, continuous integration, and refactoring. However, I think our ability to understand and capture business requirements, and then code to meet them, is a critical reason for our success. (CRISPIN, 2006, p. 71, grifo do autor) **\n###\"###\nClaro, a taxa de defeito é apenas uma pequena medida de qualidade. Se você pudesse falar com nossos stakeholders do negócio, você acharia que eles estão satisfeitos, muitas vezes até, encantados, que nós entregamos"));
        livroController.addCapitulo(capitulo("capitulo3", "#1. Fundamentação teórica#\nEste capítulo aborta os principais tópicos de qualidade que foram utilizados no trabalho.\n##1.1. Qualidade##\n__Weinberg (1993)__ aponta a questão da relatividade quanto à qualidade, pois para ele é preciso examinar com muito cuidado porque definições como “a qualidade é a conformidade às exigências” se transformam em “às exigências de alguma pessoa” isto porque o mesmo produto detém aspectos de qualidade diferentes de acordo com cada ponto de vista. Assim, __Weinberg (1993, p. 6)__ quanto às definições de qualidade de software ele se pergunta “Quem é a pessoa por trás dessa definição de qualidade?”\n__Weinberg (1993, p. 6)__ cita algumas “ideias familiares”, porém conflitantes sobre qualidade de software:\n###\"###\n\n Defeito zero é a alta qualidade\na) Para os usuários cujo trabalho é afetado pelos defeitos.\nb) Para os gerentes que são criticados pelos defeitos.\nTer um grande número de funções é alta qualidade\na) Para os usuários cujo trabalho pode tirar proveito dessas funções – se eles as conhecerem.\nb) Para os distribuidores que acreditam que as funções vendem produtos.\nCodificação elegante é alta qualidade\na) Para o pessoal de desenvolvimento que dá um grande valor às opiniões de seus colegas.\nb) Para os professores de ciência da computação que apreciam elegância.\nAlto desempenho é alta qualidade\na) Para os usuários cujo trabalho sobrecarrega a capacidade de suas máquinas.\nb) Para o pessoal de venda que tem de submeter seus produtos à benchmarks.\nBaixo custo de desenvolvimento é alta qualidade\na) Para os usuários cujo trabalho sobrecarrega a capacidade de suas máquinas.\nb) Para os gerentes do projeto que estão com orçamentos apertados.\nDesenvolvimento rápido é alta qualidade\na) Para os usuários cujo trabalho está esperando pelo software.\nb) Para os distribuidores que desejam colonizar um mercado antes de seus concorrentes.\nFacilidade para o usuário (userfriendliness) é alta qualidade\na) Para os usuários que gastam oito horas por ida na frente de uma tela utilizando o software.\nb) Para os usuários que não conseguem se lembrar de detalhes de interface (WEINBERG, 1993, p. 6-7).\n###\"###"));
        livroController.finalizarLivro();
        
    }
    
    private Capitulo capitulo(String t, String c) {
        Capitulo capitulo = new Capitulo();
        capitulo.setTitulo(t);
        capitulo.setConteudo(c);
        return capitulo;
    }
    
    
}
